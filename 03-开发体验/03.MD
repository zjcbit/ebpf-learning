# 开发与体验
开发 eBPF 程序主要分为5步：
- 使用 C 语言开发一个 eBPF 程序；
- 借助 LLVM 把 eBPF 程序编译成 BPF 字节码；
- 通过 bpf 系统调用，把 BPF 字节码提交给内核；
- 内核验证并运行 BPF 字节码，并把相应的状态保存到 BPF 映射中；
- 用户程序通过 BPF 映射查询 BPF 字节码的运行状态。
![img](https://www.brendangregg.com/eBPF/linux_ebpf_internals.png)

内核版本低于5.0时, 需要下载btf文件, 不同版本btf 下载
``` shell
https://code.alibaba-inc.com/chengshuyi.csy/vmlinux-btf/blob/master/vmlinux-btf/vmlinux-4.19.91-007.ali4000.alios7.x86_64
```
- 如果内核版本高于5.0, 可以使用如下命令生成btf文件
``` shell
bpftool btf dump file /sys/kernel/btf/vmlinux format c > vmlinux.h
```
bcc 中有很多可用的例子, 可以参考
``` shell
git clone --recurse-submodules  https://github.com/iovisor/bcc.git
cd bcc/libbpf-tools/
make
```
- 课程链接： https://time.geekbang.org/column/article/484207?screen=full
- 使用bpftrace 跟踪进程创建
``` shell
sudo bpftrace -e 'tracepoint:syscalls:sys_enter_execve,tracepoint:syscalls:sys_enter_execveat { printf("%-6d %-8s", pid, comm); join(args->argv);}'
```
可以简单的查进程的创建，但是无法查看进程的父子关系，无法查看进程的cgroup信息，无法查看进程的启动时间等信息。可以使用bpftrace的内置函数curtask来获取进程的父子关系，cgroup信息，启动时间等信息。如下：

``` shell bpftrace.sh
#!/usr/bin/bpftrace

#include <linux/sched.h>

BEGIN
{
    printf("%-9s %-6s %-6s  %-6s %-16s %s\n", "TIME", "PID", "CGROUP", "PPID", "COMM", "ARGS")
}

tracepoint:syscalls:sys_enter_execve,
tracepoint:syscalls:sys_enter_execveat
{
    $task = (struct task_struct *)curtask;

    time("%H:%M:%S  ");
    printf("%-6d %-16d %-6d %-16s ", pid, cgroup, $task->parent->tgid, comm);
    join(args->argv);
}
```
- 运行
``` shell
#bpftrace bpftrace.sh
Attaching 3 probes...
TIME      PID    CGROUP  PPID   COMM             ARGS
14:19:00  57051  1       2107   staragentd
14:19:00  57052  1       57051  su               bash -c run.sh
```

# bpftool
用它可以查看 eBPF 程序的运行状态。从以下地址安装bpftool https://github.com/libbpf/bpftool/releases
``` shell
#bpftool prog list
20: tracepoint  name sys_enter_execv  tag 55702217054eb5f7  gpl
	loaded_at 2023-07-19T09:48:52+0800  uid 0
	xlated 1984B  jited 1096B  memlock 4096B  map_ids 38,37
21: tracepoint  name sys_enter_execv  tag 147f3696721fb7e7  gpl
	loaded_at 2023-07-19T09:48:52+0800  uid 0
	xlated 1984B  jited 1096B  memlock 4096B  map_ids 38,37
```
输出中，20、21 是这个 eBPF 程序的编号，kprobe 是程序的类型，而 hello_world 是程序的名字。有了 eBPF 程序编号之后，执行下面的命令就可以导出这个 eBPF 程序的指令：
``` shell
#bpftool prog dump xlated id 20
   0: (bf) r6 = r1
   1: (85) call bpf_get_current_task#-49424
   2: (bf) r7 = r0
   3: (b7) r1 = 30004
   4: (7b) *(u64 *)(r10 -72) = r1
   5: (b7) r9 = 0
   6: (63) *(u32 *)(r10 -64) = r9
   7: (18) r8 = map[id:38]
   9: (85) call bpf_get_smp_processor_id#70272
   ... 
```
BPF 指令又分为三部分:
- 第一部分，冒号前面的数字 0-9 ，代表 BPF 指令行数；
- 第二部分，括号中的 16 进制数值，表示 BPF 指令码。它的具体含义你可以参考 [IOVisor BPF](https://github.com/iovisor/bpf-docs/blob/master/eBPF.md) 文档，比如第 0 行的 0xbf 表示为```mov dst, src ```
- 第三部分，括号后面的部分，就是 BPF 指令的伪代码。
当这些 BPF 指令加载到内核后， BPF 即时编译器会将其即时编译(JIT)成本地机器指令，最后才会执行编译后的机器指令
```shell
#bpftool prog dump jited  id 20
   0:	pushq	%rbp
   1:	movq	%rsp, %rbp
   4:	subq	$72, %rsp
   b:	pushq	%rbx
   c:	pushq	%r13
   e:	pushq	%r14
  10:	pushq	%r15
  12:	pushq	$0
  14:	movq	%rdi, %rbx
  17:	callq	0xffffffffc11523d3
  ...
``` 
这些机器指令的含义跟前面的 BPF 指令是类似的，但具体的指令和寄存器都换成了 x86 的格式。
那么bpf程序是何时执行的呢
``` shell
#sudo strace -v -f -ebpf bpftrace bpftrace.sh
strace: Process 29611 attached
[pid 29611] +++ exited with 0 +++
strace: Process 29614 attached
[pid 29614] +++ exited with 0 +++
bpf(BPF_PROG_LOAD, {prog_type=BPF_PROG_TYPE_KPROBE, insn_cnt=2, insns=[{code=BPF_JMP|BPF_K|BPF_CALL, dst_reg=BPF_REG_0, src_reg=BPF_REG_0, off=0, imm=0x50}, {code=BPF_JMP|BPF_K|BPF_EXIT, dst_reg=BPF_REG_0, src_reg=BPF_REG_0, off=0, imm=0}], license="GPL", log_level=1, log_size=4096, log_buf="", kern_version=KERNEL_VERSION(0, 0, 0), prog_flags=0, prog_name="", prog_ifindex=0, expected_attach_type=BPF_CGROUP_INET_INGRESS}, 120) = -1 EINVAL (Invalid argument)
bpf(BPF_MAP_CREATE, {map_type=BPF_MAP_TYPE_PERCPU_ARRAY, key_size=4, value_size=16400, max_entries=1, map_flags=0, inner_map_fd=0, map_name="join", map_ifindex=0}, 120) = 3
bpf(BPF_MAP_CREATE, {map_type=BPF_MAP_TYPE_PERF_EVENT_ARRAY, key_size=4, value_size=4, max_entries=32, map_flags=0, inner_map_fd=0, map_name="printf", map_ifindex=0}, 120) = 4
Attaching 3 probes...
bpf(BPF_MAP_UPDATE_ELEM, {map_fd=4, key=0x7ffd41f6ff5c, value=0x7ffd41f6ff60, flags=BPF_ANY}, 120) = 0
```
这些参数看起来很复杂，但实际上，如果你查询 bpf 系统调用的格式（执行 man bpf 命令），就可以发现，它实际上只需要三个参数：
``` c
int bpf(int cmd, union bpf_attr *attr, unsigned int size);
```
对应前面的 strace 输出结果，这三个参数的具体含义如下：
- 第一个参数是 BPF_PROG_LOAD ， 表示加载 BPF 程序。
- 第二个参数是 bpf_attr 类型的结构体，表示 BPF 程序的属性。
  - 其中，有几个需要你留意的参数，比如：prog_type 表示 BPF 程序的类型，这儿是 BPF_PROG_TYPE_KPROBE ，
  - insn_cnt (instructions count) 表示指令条数；
  - insns (instructions) 包含了具体的每一条指令；
  - prog_name 则表示 BPF 程序的名字。
- 第三个参数 120 表示属性的大小。